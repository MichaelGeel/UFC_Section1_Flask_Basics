#Section 1: Flask Basics Notes

## 1) Installation on Windows

To install virtual environment:
    "py -m venv 'venv name'"
It'll then install, and to activate it:
    "env/Scripts/activate"
When it's activated, will then see an "(env)" at the beginning of each terminal line.
Will then install flask into the environment using:
    "pip install flask"
We'll then create our ain app file and name it:
    "app.py"
We'll set an environment variable in the command prompt:
    "set FLASK_APP = app.py"
This allows flask to know hwat file to look for when it wants to run.
It doesn't have to be app.py, but it is by conventional best practice and saves
on having to specify otherwise.
Now on to writing the code (see app.py for the code and notes.)
Note that an extra step was made necessary, VS Code had failed to detect the python
executable in the virtual environment, so in the root folder a ".vscode" folder had to be made,
within it, a settings.json file was created and contained the following json code:
    {
    "python.pythonPath": "$Section1_Flask_Basics/env/Scripts/python"
    }
This json code effectively tells vs code where in the projects root to find the python interpreter for
this particular project.
Having resolved all issues and successfully imported the Flask class, we'll now instantiate it.
When instantiating the class, we'll always pass the __name__ parameter to it, as this references the module that we're 
creating the Flask object in.
Well now create our first route for the object.
A route is essentially a URL endpoint for a particular thing in the app being created.
The base or index or home route is generally just a plain "/" however when creating more routes, we'll add a 
word after the slash which will normally be indicative of the route's function.
Every route will be linked to a function that you'll have to define.
Note that the index route is the base URL for your site.
The @app.route line is referring to as a Decorator.
In the return for the function, it returns directly to the browser, so if what is being returned is html, then the 
browser will interpret it as such and will show it to you.
To run and test this code, in the terminal we'll type
    "flask run"
and because we declared the environment variable earlier, flask knows what to run and will run your app.py file.
Note that if you haven't saved the creation of the flask app before using flask run it'll error out, be sure to save 
the work first.
Once it's running we'll get some feedback regarding the runtime being a development server, the debug mode config and 
also the local URL that the dev server is running on, which we can copy and paste into our browser to view the web page.
Once you've entered it into your browser, you'll see the Hello! heading created in the return being displayed.
We'll now make this morning interesting by allowing a name to be passed into the route.
Any placeholder added to the endpoint in a decorator needs to be accounted for in the function as a parameter passed to it.
For future reference, in this course we'll be using the .format() means of adding variables to strings as opposed to the 
f"" method.
Remember when using .format, we only put in an empty set of {} in the string itself to indicate where the 
format inserts the variables.
In the terminal, we can use CTRL + C to stop the server and flask run again to restart it.
Remember to save the work before restarting or else it won't register.
Having done this now if we just reload the URL passed in the terminal itself the browser will show a "Not Found" error.
This is because the endpoint in that state no longer exists, as placeholder has now made it a different endpoint and we 
have to pass something in the url to satisfy the placeholder requirement in the URL.
For this I'll just use my own name and add: "/Michael" to the end of the URL and it'll now load successfully and have
passed my name through the route function to display "Hello Michael!" in the browser.
Note that with placeholders you can pass just about anything in to that URL.

## 2) The Two Ways of Running Flask Apps:

There are a few ways of getting a flask app running.
The first method being to have the following code block at the bottom of the code:
    "if __name__ == '__main__':
        app.run()
        "
This allows you to call the file directly using python, so in your terminal type:
    "python app.py"
This will then start the server.
In newer versions, activating debug mode in the code block (app.run(debug=True)) causes errors.
The alternative approach is using the "flask run" command.
And if your main program file is "app.py" it'll pickup automatically and start the server.
However, if the file name is something different then you have to export an environment variable to tell flask the name.
    "export FLASK_APP=(file_name)"
With this method, if you want to use debug mode, you have to export flask debug:
    "export FLASK_DEBUG=1"
Either approach is viable and only gets used on your development machine, when you go to deploy your flask app an entirely
different approach is used.

## 3) Installation and Hello World:

Since lesson 1 covered the installation and activation of a virtual environment along with a small hello world intro
there may not be much new content in this lesson.
Have just removed the name placeholder to reset the code to match that of the lesson.

## 4) Installation Using Pipenv:

An additional alternative we'll look at now is using pipenv to install and flask run to run alongside it.
Pipenv is an easy way to install packages as it combines pip and a virtual environment.
Instead of creating a virtual environment first and then installing with pip, you just use pipenv to do everything.
If you don't have it, install it using pip:
    "pip install pipenv"
Now to use it is pretty straightforward, whenever you'd install something with pip, you just do so with pipenv instead:
    "pipenv install flask"
It'll go ahead and install the library for us, then once it's installed, we can run
    "pipenv shell"
which will start up the virtual environment for us.
It'll name the virtual environment based on whatever folder you're in at the moment.
once the virtual environment is activate, if you want to install any other libraries you just do so with pipenv again.
Then just like always we can just type flask run to run the app.

## 5) Intro to Routes:

Routes are an essential component to our apps.
Routes are how people are going to access different areas of your app or different parts of your API, whichever the case may be.
As we've done in the examples thus far, our routes have only contained a ('/'), which signifies the index.
But if we wanted to create a home route, we'd then add the word "home" after the slash:
    "@app.route('/home')"
then we'd naturally create a function that accompanies this route.
Note that the function doens't need to have the same name as the route, but it's easier to track the routes that way.
Now if you save the changes and rerun the app, you'll load in once again on the index page, but if you add a "/home" to 
the end of the URL, you'll find yourself one the home page.
If you try to add something undefined to the end of the URL that you haven't created a route for, you'll get a Not Found error.
In a route, whenever you return a string, it gets automatically converted into HTML which you'll see as a result.
You don't necessarily have to return HTML, it's just the most straightforward way to do so.
If for example you want to return JSON, then you need to use the jsonify function.
We'll import jsonify from flask.
And create another route named /json to return jsonified Python data structures.
A python list maps to a json array and python dictionary to a json object.
See the accompanying coded route for the exmaple of this.
The browser will return the json output as per the python data structure we fed into the jsonify function.
If you don't want to have end and restart the app for every change made, you can add the debug=True parameter to the
app.run and that'll cause the browser to constantly refresh as you make changes to your code.
Note there other ways to activate debug mode that we'll explore later on.

## 6) Route Methods

By default, endpoints created by the app.route decorator are for GET requests only.
If you go to postman to try a POST request to one of the routes, doing a GET request to the url works fine and you get
the response, however if you change the request type to POST, you'll see it give an error request type not allowed.
If you want to change the method on a particular route to allow diffreetn types of HTTP requests to come in, we simply add:
    "methods=['GET', 'POST']"
inside the app.route decorator, and this lists the types of requests that can be made to that particular route.
A GET request is always the default request type, and it's where a browser or API call is just getting information and
not modifying anything.
So if you want to make it a POST request, you simply add POST to the list of methods in the decorator, than when you
go back to postman and retry the call it'll succeed and provide a response.
Note that in the browser, you'll be always performing a get request if you put the url in the search bar and if a route
doesn't allow for get requests, then you'll get a 405 not allowed response.
